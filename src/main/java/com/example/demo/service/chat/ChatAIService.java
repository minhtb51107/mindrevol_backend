package com.example.demo.service.chat;

import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.Set;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;
import java.util.stream.Collectors;

import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.scheduling.annotation.Async;
import org.springframework.stereotype.Service;

import com.example.demo.dto.chat.ChatMessageDTO;
import com.example.demo.model.auth.User;
import com.example.demo.model.chat.ChatMessage;
import com.example.demo.model.chat.ChatSession;
import com.example.demo.model.chat.EmotionContext;
// import com.example.demo.model.chat.MemorySummary; // üî• ƒê√É X√ìA
import com.example.demo.model.chat.ConversationState;
import com.example.demo.repository.chat.ChatSessionRepository;
import com.example.demo.repository.chat.ConversationStateRepository.ConversationStateRepository;
import com.example.demo.repository.chat.EmotionContextRepository.EmotionContextRepository;
import com.example.demo.repository.chat.UserPreferenceRepository.UserPreferenceRepository;
// import com.example.demo.repository.chat.memory.MemorySummaryRepo; // üî• ƒê√É X√ìA
import com.example.demo.service.chat.chunking.TokenCounterService;
import com.example.demo.service.chat.context.ContextCompressionService;
import com.example.demo.service.chat.emotion.EmotionAnalysisService;
import com.example.demo.service.chat.preference.UserPreferenceService;
import com.example.demo.service.chat.reranking.RerankingService;
import com.example.demo.service.chat.state.ConversationStateService;
//import com.example.demo.service.chat.util.SpringAIEmbeddingService;
//import com.example.demo.service.chat.util.EmbeddingService;
import com.example.demo.service.chat.util.TokenManagementService;
//import com.example.demo.service.chat.vector.VectorStoreService;
import com.github.benmanes.caffeine.cache.Cache;
import com.github.benmanes.caffeine.cache.Caffeine;

import dev.langchain4j.data.document.Metadata;
import dev.langchain4j.data.embedding.Embedding;
import dev.langchain4j.data.message.AiMessage;
import dev.langchain4j.data.message.SystemMessage;
import dev.langchain4j.data.message.UserMessage;
import dev.langchain4j.data.segment.TextSegment;
import dev.langchain4j.memory.ChatMemory;
import dev.langchain4j.model.chat.ChatLanguageModel;
import dev.langchain4j.model.embedding.EmbeddingModel;
import dev.langchain4j.model.output.Response;
import dev.langchain4j.rag.content.Content;
import dev.langchain4j.rag.content.retriever.ContentRetriever;
import dev.langchain4j.rag.query.Query;
import dev.langchain4j.store.embedding.EmbeddingStore;

import com.example.demo.service.chat.fallback.FallbackService;
//import com.example.demo.service.chat.integration.OpenAIService;
//import com.example.demo.service.chat.integration.SpringAIChatService;
// import com.example.demo.service.chat.memory.HierarchicalMemoryManager; // üî• ƒê√É X√ìA
// import com.example.demo.service.chat.memory.MemorySummaryManager; // üî• ƒê√É X√ìA
// import com.example.demo.service.chat.memory.PromptBuilder; // üî• ƒê√É X√ìA
// import com.example.demo.service.chat.memory.RedisChatMemoryService; // üî• ƒê√É X√ìA
import com.example.demo.service.chat.memory.langchain.ConversationSummaryService;
import com.example.demo.service.chat.memory.langchain.LangChainChatMemoryService;

import dev.langchain4j.store.embedding.EmbeddingSearchRequest;
import dev.langchain4j.store.embedding.EmbeddingSearchResult;
import dev.langchain4j.store.embedding.filter.Filter;
import dev.langchain4j.store.embedding.filter.comparison.IsEqualTo;
import dev.langchain4j.store.embedding.filter.logical.And;
import dev.langchain4j.store.embedding.filter.logical.Or;
import dev.langchain4j.store.embedding.EmbeddingMatch;
import java.util.Map;
import java.util.stream.Collectors;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

@Slf4j
@Service
@RequiredArgsConstructor
public class ChatAIService {
    // private final RedisChatMemoryService redisChatMemoryService; // üî• ƒê√É X√ìA
    private final ChatSessionRepository sessionRepo;
    private final ChatMessageService messageService;
    // private final MemorySummaryManager memoryManager; // üî• ƒê√É X√ìA
    // private final PromptBuilder promptBuilder; // üî• ƒê√É X√ìA
    //private final OpenAIService openAIService;
    //private final SpringAIChatService springAIChatService;
    //private final SpringAIEmbeddingService embeddingService;
    //private final EmbeddingService embeddingService;
    //private final VectorStoreService vectorStoreService;
    
    // ‚úÖ C√ÅC SERVICES M·ªöI
    private final EmotionAnalysisService emotionAnalysisService;
    private final UserPreferenceService userPreferenceService;
    private final ConversationStateService conversationStateService;
    private final FallbackService fallbackService;
    
    // ‚úÖ REPOSITORIES
    private final EmotionContextRepository emotionContextRepository;
    private final ConversationStateRepository conversationStateRepository;
    private final UserPreferenceRepository userPreferenceRepository;
    
    private final TokenCounterService tokenCounterService;
    
    // private final HierarchicalMemoryManager hierarchicalMemoryManager; // üî• ƒê√É X√ìA
    
    // private final MemorySummaryRepo summaryRepo; // üî• ƒê√É X√ìA
    
    private final LangChainChatMemoryService langChainChatMemoryService; // ‚úÖ ƒê√É H·ª¢P NH·∫§T
    private final ConversationSummaryService conversationSummaryService;
    private final ChatLanguageModel chatLanguageModel;
    private final EmbeddingStore<TextSegment> embeddingStore;
    private final EmbeddingModel embeddingModel;
    
    private final RerankingService rerankingService; 
    // private final LangChainChatMemoryService langChain4jMemoryService; // üî• ƒê√É X√ìA (B·ªã tr√πng)


 // TRONG ChatAIService.java
    public String processMessages(Long sessionId, List<ChatMessageDTO> messageDTOs, User user) {
        try {
            ChatSession session = sessionRepo.findById(sessionId)
                    .orElseThrow(() -> new IllegalArgumentException("Session kh√¥ng t·ªìn t·∫°i"));

            String prompt = messageDTOs.get(messageDTOs.size() - 1).getContent();
            ChatMemory chatMemory = langChainChatMemoryService.getChatMemory(sessionId);

            if (chatMemory.messages().isEmpty()) {
                 log.debug("Chat memory for session {} is empty. Hydrating from database...", sessionId);
                 hydrateChatMemoryFromDB(chatMemory, sessionId);
            }

            // === üî• LOGIC B·ªò NH·ªö D√ÄI H·∫†N ƒê√É ƒê∆Ø·ª¢C ƒê∆†N GI·∫¢N H√ìA ===
            // Bi·∫øn n√†y kh√¥ng c·∫ßn thi·∫øt n·ªØa v√¨ chatMemory.messages() ƒë√£ ch·ª©a t√≥m t·∫Øt
            // String longTermContext = conversationSummaryService.getSummaryForPrompt(session); // üî• ƒê√É X√ìA
            
            Map<String, Object> userPrefsMap = userPreferenceService.getUserPreferencesForPrompt(user.getId());
            runContextAnalysisAsync(session, user, prompt);

            
            // === B·∫ÆT ƒê·∫¶U PIPELINE ƒêI·ªÄU PH·ªêI (ORCHESTRATION) ===

            String ragContext = ""; 
            String reply;
            
            QueryIntent intent = classifyQueryIntent(prompt);
            log.debug("Query intent classified as: {}", intent);

            if (intent == QueryIntent.CHITCHAT) {
                // Lu·ªìng 1: CHITCHAT
                log.debug("Handling as CHITCHAT. Skipping RAG.");
                
                 // ‚úÖ S·ª¨A ƒê·ªîI: Ch·ªâ c·∫ßn truy·ªÅn chatMemory.messages()
                 List<dev.langchain4j.data.message.ChatMessage> lcMessages = 
                        buildFinalLc4jMessages(chatMemory.messages(), ragContext, userPrefsMap, prompt);
                
                 // G·ªçi AI
                chatMemory.add(UserMessage.from(prompt));
                Response<AiMessage> response = chatLanguageModel.generate(lcMessages); 
                reply = response.content().text();
                chatMemory.add(AiMessage.from(reply));

            } else if (intent == QueryIntent.MEMORY_QUERY) {
                // Lu·ªìng 2: MEMORY_QUERY
                log.debug("Handling as MEMORY_QUERY. Using direct memory handler.");
                reply = handleMemoryQuestion(chatMemory, prompt);
                
                chatMemory.add(UserMessage.from(prompt));
                chatMemory.add(AiMessage.from(reply));
                
            } else {
                // Lu·ªìng 3: RAG_QUERY
                log.debug("Handling as RAG_QUERY. Running full RAG pipeline.");
                
                // ... (Logic RAG gi·ªØ nguy√™n) ...
                Embedding queryEmbedding = embeddingModel.embed(prompt).content();
                Filter sessionMessageFilter = new IsEqualTo("sessionId", session.getId().toString());
                Filter userKnowledgeFilter = new And(
                    new IsEqualTo("userId", user.getId().toString()),
                    new IsEqualTo("docType", "knowledge") 
                );
                Filter finalFilter = new Or(sessionMessageFilter, userKnowledgeFilter);

                EmbeddingSearchRequest request = EmbeddingSearchRequest.builder()
                        .queryEmbedding(queryEmbedding)
                        .maxResults(20) 
                        .filter(finalFilter)
                        .build();

                EmbeddingSearchResult<TextSegment> searchResult = embeddingStore.search(request);
                List<EmbeddingMatch<TextSegment>> initialMatches = searchResult.matches();

                List<EmbeddingMatch<TextSegment>> rerankedMatches;
                if (isTechnicalQuery(prompt)) {
                    log.debug("Technical query detected. Using local HYBRID rerank.");
                    Map<String, Double> weights = Map.of("semantic", 0.4, "recency", 0.3, "keyword", 0.3);
                    rerankedMatches = rerankingService.hybridRerank(prompt, initialMatches, weights, 5);
                } else {
                    log.debug("Semantic query detected. Using COHERE rerank.");
                    rerankedMatches = rerankingService.rerankResults(prompt, initialMatches, 5);
                }

                ragContext = rerankedMatches.stream()
                        .map(match -> match.embedded().text())
                        .collect(Collectors.joining("\n---\n"));

                // ‚úÖ S·ª¨A ƒê·ªîI: Ch·ªâ c·∫ßn truy·ªÅn chatMemory.messages()
                List<dev.langchain4j.data.message.ChatMessage> lcMessages = 
                        buildFinalLc4jMessages(chatMemory.messages(), ragContext, userPrefsMap, prompt);
                
                // G·ªçi AI
                chatMemory.add(UserMessage.from(prompt));
                Response<AiMessage> response = chatLanguageModel.generate(lcMessages); 
                reply = response.content().text();
                chatMemory.add(AiMessage.from(reply));
            }

            // === L∆ØU TR·ªÆ (LU√îN CH·∫†Y) ===
            ChatMessage userMsgDb = messageService.saveMessage(session, "user", prompt);
            ChatMessage aiMsgDb = messageService.saveMessage(session, "assistant", reply);
            saveMessagesToVectorStore(userMsgDb, aiMsgDb, session); 
            
            return reply;

        } catch (Exception e) {
            log.error("L·ªói x·ª≠ l√Ω processMessages: {}", e.getMessage(), e);
            return fallbackService.getEmergencyResponse();
        }
    }
 
    // ... (C√°c ph∆∞∆°ng th·ª©c kh√°c gi·ªØ nguy√™n) ...
    
    @Async
    private void saveMessagesToVectorStore(ChatMessage userMessage, ChatMessage aiMessage, ChatSession session) {
     try {
         // Chuy·ªÉn ƒë·ªïi c·∫£ hai tin nh·∫Øn sang TextSegments
         TextSegment userSegment = createSegmentFromMessage(userMessage, session);
         TextSegment aiSegment = createSegmentFromMessage(aiMessage, session);

         // Nh√∫ng (embed) c·∫£ hai
         Embedding userEmbedding = embeddingModel.embed(userSegment).content();
         Embedding aiEmbedding = embeddingModel.embed(aiSegment).content();

         // Th√™m c·∫£ hai v√†o embedding store
         embeddingStore.add(userEmbedding, userSegment);
         embeddingStore.add(aiEmbedding, aiSegment);
         
         log.debug("ƒê√£ l∆∞u 2 tin nh·∫Øn (User: {}, AI: {}) v√†o vector store cho session {}", 
             userMessage.getId(), aiMessage.getId(), session.getId());

     } catch (Exception e) {
         // Ch√∫ng ta kh√¥ng mu·ªën l√†m s·∫≠p lu·ªìng chat ch√≠nh n·∫øu vi·ªác nh√∫ng l·ªói
         log.warn("Kh√¥ng th·ªÉ l∆∞u message embeddings v√†o vector store: {}", e.getMessage());
     }
    }

    private TextSegment createSegmentFromMessage(ChatMessage message, ChatSession session) {
     // ƒê√¢y l√† n∆°i ch√∫ng ta th√™m t·∫•t c·∫£ metadata m√† RerankingService s·∫Ω c·∫ßn
     Metadata metadata = Metadata.from(Map.of(
         "messageId", message.getId().toString(),
         "sessionId", session.getId().toString(),
         "senderType", message.getSender(),
         "messageTimestamp", message.getTimestamp().toString() // Quan tr·ªçng cho hybrid rerank
         // "detectedTopic", "..." // (B·∫°n c√≥ th·ªÉ th√™m logic ph√°t hi·ªán topic ·ªü ƒë√¢y)
     ));
     
     return TextSegment.from(message.getContent(), metadata);
    }
    
    private void hydrateChatMemoryFromDB(ChatMemory chatMemory, Long sessionId) {
        try {
            // L·∫•y 20 tin nh·∫Øn g·∫ßn nh·∫•t t·ª´ SQL
            List<ChatMessage> recentDbMessages = messageService.getRecentMessages(sessionId, 20);

            if (recentDbMessages.isEmpty()) {
                return;
            }
            
            // Chuy·ªÉn ƒë·ªïi t·ª´ model DB (ChatMessage) sang model c·ªßa LangChain4j 
            // (dev.langchain4j.data.message.ChatMessage)
            // L∆∞u √Ω: Ch√∫ng ta ph·∫£i th√™m ch√∫ng theo ƒë√∫ng th·ª© t·ª± (c≈© ƒë·∫øn m·ªõi)
            for (ChatMessage dbMsg : recentDbMessages) {
                if ("user".equalsIgnoreCase(dbMsg.getSender())) {
                    chatMemory.add(UserMessage.from(dbMsg.getContent()));
                } else if ("assistant".equalsIgnoreCase(dbMsg.getSender())) {
                    chatMemory.add(AiMessage.from(dbMsg.getContent()));
                }
                // (Ch√∫ng ta c√≥ th·ªÉ b·ªè qua c√°c tin nh·∫Øn "system" trong l·ªãch s·ª≠ DB 
                // v√¨ system prompt ƒë∆∞·ª£c x√¢y d·ª±ng ri√™ng)
            }
        } catch (Exception e) {
            log.warn("Failed to hydrate chat memory from DB for session {}: {}", sessionId, e.getMessage());
        }
    }

 // Trong file: demo-2/src/main/java/com/example/demo/service/chat/ChatAIService.java

    /**
     * ‚úÖ THAY ƒê·ªîI SIGNATURE: Lo·∫°i b·ªè 'longTermContext'
     */
    private List<dev.langchain4j.data.message.ChatMessage> buildFinalLc4jMessages(
            List<dev.langchain4j.data.message.ChatMessage> history, // history n√†y ƒë√£ ch·ª©a t√≥m t·∫Øt
            String ragContext, 
            Map<String, Object> userPrefsMap, 
            String currentQuery) {

        List<dev.langchain4j.data.message.ChatMessage> messages = new ArrayList<>();

        StringBuilder sb = new StringBuilder();
        sb.append("B·∫°n l√† tr·ª£ l√Ω AI h·ªØu √≠ch.\n");

        if (userPrefsMap != null && !userPrefsMap.isEmpty()) {
            sb.append("\n--- S·ªû TH√çCH C·ª¶A NG∆Ø·ªúI D√ôNG ---\n");
            userPrefsMap.forEach((key, value) -> {
                sb.append(String.format("%s: %s\n", key, value != null ? value.toString() : "N/A"));
            });
        }

        // üî• ƒê√É X√ìA KH·ªêI LOGIC 'longTermContext' V√å N√ì ƒê√É C√ì TRONG 'history'
        // if (longTermContext != null && !longTermContext.isBlank()) { ... }

        sb.append("\n--- B·ªêI C·∫¢NH NG·∫ÆN H·∫†N (T·ª™ RAG) ---\n");
        sb.append(ragContext.isEmpty() ? "Kh√¥ng c√≥" : ragContext).append("\n");
        sb.append("\n--- H·∫æT B·ªêI C·∫¢NH ---\n\nH√£y tr·∫£ l·ªùi c√¢u h·ªèi hi·ªán t·∫°i.");

        messages.add(SystemMessage.from(sb.toString()));

        // 'history' ƒë√£ bao g·ªìm (T√≥m t·∫Øt + tin nh·∫Øn g·∫ßn ƒë√¢y)
        messages.addAll(history); 
        
        // Ch·ªâ th√™m c√¢u h·ªèi hi·ªán t·∫°i (n√≥ ch∆∞a c√≥ trong history)
        // L∆ØU √ù: ƒê·∫£m b·∫£o 'history' kh√¥ng bao g·ªìm currentQuery
        // (Trong logic ·ªü tr√™n, ch√∫ng ta add(UserMessage) SAU khi build prompt, n√™n ƒëi·ªÅu n√†y l√† ƒê√öNG)
        
        // messages.add(UserMessage.from(currentQuery)); // B·ªä TR√ôNG L·∫∂P N·∫æU history ƒê√É BAO G·ªíM N√ì
        
        // KI·ªÇM TRA L·∫†I:
        // 1. chatMemory.messages() ƒë∆∞·ª£c g·ªçi -> tr·∫£ v·ªÅ [Summary, msg1, msg2]
        // 2. buildFinalLc4jMessages(history, ...) ƒë∆∞·ª£c g·ªçi
        // 3. chatMemory.add(UserMessage.from(prompt)) ƒë∆∞·ª£c g·ªçi
        
        // -> V√¨ v·∫≠y, 'history' ch∆∞a ch·ª©a 'currentQuery'. Ch√∫ng ta c·∫ßn th√™m n√≥.
        // NH∆ØNG, trong code c≈© c·ªßa b·∫°n, 'currentQuery' L√Ä tin nh·∫Øn cu·ªëi c√πng trong 'history'.
        // H√£y ki·ªÉm tra l·∫°i `processMessages`:
        
        // 1. chatMemory.add(UserMessage.from(prompt)); // <- B·∫°n th√™m n√≥ V√ÄO B·ªò NH·ªö
        // 2. Response<AiMessage> response = chatLanguageModel.generate(lcMessages); // <- B·∫°n g·ªçi generate
        // 3. chatMemory.add(AiMessage.from(reply)); // <- B·∫°n th√™m ph·∫£n h·ªìi
        
        // A-ha! Trong code c·ªßa b·∫°n, `buildFinalLc4jMessages` ƒë∆∞·ª£c g·ªçi TR∆Ø·ªöC khi `chatMemory.add(UserMessage.from(prompt))`.
        
        // V·∫¨Y TH√å: 
        // 1. `history = chatMemory.messages()` (Ch∆∞a ch·ª©a prompt hi·ªán t·∫°i)
        // 2. `lcMessages = buildFinalLc4jMessages(history, ...)`
        // 3. Ph∆∞∆°ng th·ª©c `buildFinalLc4jMessages` C·∫¶N th√™m `currentQuery`.
        
        // H√ÉY XEM L·∫†I buildFinalLc4jMessages g·ªëc c·ªßa b·∫°n:
        /*
        private List<dev.langchain4j.data.message.ChatMessage> buildFinalLc4jMessages(
            ...
            String currentQuery) {
            ...
            messages.addAll(history); 
            messages.add(UserMessage.from(currentQuery)); // <- N√ì ƒê√ÇY R·ªíI
            return messages;
        }
        */
       
       // -> V·∫≠y code c·ªßa t√¥i ·ªü tr√™n L√Ä ƒê√öNG. 
       // history kh√¥ng ch·ª©a currentQuery, v√† ch√∫ng ta th√™m n√≥ v√†o cu·ªëi.

        messages.addAll(history); 
        messages.add(UserMessage.from(currentQuery));

        return messages;
    }
    
    // ... (Ph·∫ßn c√≤n l·∫°i c·ªßa ChatAIService.java gi·ªØ nguy√™n) ...

    @Async 
    protected void runContextAnalysisAsync(ChatSession session, User user, String prompt) {
        try {
            // 1. Ph√¢n t√≠ch c·∫£m x√∫c (S·ª≠a l·ªói Constructor)
            EmotionContext emotionContext = emotionContextRepository.findByChatSession_Id(session.getId())
                    .orElseGet(() -> {
                        EmotionContext ctx = new EmotionContext(); // T·∫°o tr·ªëng
                        ctx.setChatSession(session); // Set th·ªß c√¥ng
                        ctx.setUser(user);         // Set th·ªß c√¥ng
                        return ctx;
                    }); // ‚úÖ ƒê√É S·ª¨A
            emotionAnalysisService.analyzeEmotion(prompt, emotionContext);
            emotionContextRepository.save(emotionContext);

            // 2. C·∫≠p nh·∫≠t tr·∫°ng th√°i h·ªôi tho·∫°i
            ConversationState state = conversationStateService.getOrCreateState(session.getId());
            // ‚õî X√ìA D√íNG L·ªñI: conversationStateService.updateConversationState(state, prompt); 
            // (Ph∆∞∆°ng th·ª©c n√†y kh√¥ng t·ªìn t·∫°i trong service c·ªßa b·∫°n)
            conversationStateRepository.save(state);

            log.debug("ƒê√£ c·∫≠p nh·∫≠t Context (Emotion, State) b·∫•t ƒë·ªìng b·ªô cho session {}", session.getId());
        } catch (Exception e) {
            log.warn("L·ªói c·∫≠p nh·∫≠t context b·∫•t ƒë·ªìng b·ªô: {}", e.getMessage());
        }
    }
    
    // üî• TH√äM PH∆Ø∆†NG TH·ª®C X·ª¨ L√ù C√ÇU H·ªéI MEMORY
    private String handleMemoryQuestion(ChatMemory chatMemory, String currentPrompt) {
        List<dev.langchain4j.data.message.ChatMessage> messages = chatMemory.messages();
        
        if (messages.isEmpty()) {
            return "Ch√∫ng ta ch∆∞a c√≥ cu·ªôc tr√≤ chuy·ªán n√†o tr∆∞·ªõc ƒë√≥.";
        }
        
        // L·ªçc ch·ªâ l·∫•y tin nh·∫Øn user (b·ªè qua system messages v√† AI responses)
        List<String> userMessages = messages.stream()
            .filter(msg -> msg instanceof UserMessage)
            .map(dev.langchain4j.data.message.ChatMessage::text)
            .filter(msg -> !msg.equals(currentPrompt)) // B·ªè qua c√¢u h·ªèi hi·ªán t·∫°i
            .collect(Collectors.toList());
        
        if (userMessages.isEmpty()) {
            return "T√¥i ch∆∞a nh·∫≠n ƒë∆∞·ª£c tin nh·∫Øn n√†o t·ª´ b·∫°n tr∆∞·ªõc ƒë√¢y.";
        }
        
        // L·∫•y tin nh·∫Øn user g·∫ßn nh·∫•t
        String lastUserMessage = userMessages.get(userMessages.size() - 1);
        
        // Tr·∫£ v·ªÅ c√¢u tr·∫£ l·ªùi th√¥ng minh h∆°n
        return "B·∫°n v·ª´a nh·∫Øn: \"" + lastUserMessage + "\". " +
               "B·∫°n mu·ªën t√¥i gi·∫£i th√≠ch th√™m hay c√≥ c√¢u h·ªèi g√¨ v·ªÅ ƒëi·ªÅu n√†y kh√¥ng?";
    }

    // üî• C·∫¨P NH·∫¨T PH∆Ø∆†NG TH·ª®C NH·∫¨N DI·ªÜN C√ÇU H·ªéI MEMORY
    private boolean isMemoryRelatedQuestion(String prompt) {
        String lowerPrompt = prompt.toLowerCase();
        return lowerPrompt.contains("v·ª´a nh·∫Øn") || 
               lowerPrompt.contains("v·ª´a n√≥i") ||
               lowerPrompt.contains("tr∆∞·ªõc ƒë√≥") ||
               lowerPrompt.contains("nh·∫Øc l·∫°i") ||
               lowerPrompt.contains("n√≥i g√¨") ||
               lowerPrompt.matches(".*t√¥i.*v·ª´a.*n√≥i.*g√¨.*") ||
               lowerPrompt.matches(".*t√¥i.*v·ª´a.*nh·∫Øn.*g√¨.*") ||
               lowerPrompt.contains("what did i say") ||
               lowerPrompt.contains("what was my last message");
    }

    private List<Map<String, String>> convertToPromptFormat(List<dev.langchain4j.data.message.ChatMessage> messages) {
        List<Map<String, String>> prompt = new ArrayList<>();
        
        prompt.add(Map.of(
            "role", "system",
            "content", "B·∫°n l√† tr·ª£ l√Ω AI th√¥ng minh. H√£y tr·∫£ l·ªùi t·ª± nhi√™n v√† h·ªØu √≠ch."
        ));
        
        for (dev.langchain4j.data.message.ChatMessage message : messages) {
            String role = message instanceof UserMessage ? "user" : 
                         message instanceof AiMessage ? "assistant" : "system";
            
            prompt.add(Map.of(
                "role", role,
                "content", message.text()
            ));
        }
        
        return prompt;
    }
    

    
    private String buildSystemPrompt(ChatSession session, User user) {
        // Gi·ªØ l·∫°i logic system prompt hi·ªán t·∫°i nh∆∞ng ƒë∆°n gi·∫£n h√≥a
        return "B·∫°n l√† tr·ª£ l√Ω AI th√¥ng minh. H√£y tr·∫£ l·ªùi t·ª± nhi√™n v√† h·ªØu √≠ch.";
    }
    
    private ChatMessage convertToChatMessage(dev.langchain4j.data.message.ChatMessage lcMessage, ChatSession session) {
        ChatMessage message = new ChatMessage();
        message.setChatSession(session);
        
        if (lcMessage instanceof UserMessage) {
            message.setSender("user");
            message.setContent(lcMessage.text());
        } else if (lcMessage instanceof AiMessage) {
            message.setSender("assistant");
            message.setContent(lcMessage.text());
        } else if (lcMessage instanceof SystemMessage) {
            message.setSender("system");
            message.setContent(lcMessage.text());
        }
        
        return message;
    }
    
    private enum QueryIntent {
        RAG_QUERY,      // C√¢u h·ªèi c·∫ßn t√¨m ki·∫øm ng·ªØ c·∫£nh
        CHITCHAT,       // Ch√†o h·ªèi x√£ giao
        MEMORY_QUERY    // ‚úÖ TH√äM TR·∫†NG TH√ÅI M·ªöI: C√¢u h·ªèi v·ªÅ b·ªô nh·ªõ
    }

    private QueryIntent classifyQueryIntent(String query) {
        // 1. ‚úÖ PRE-FILTER: L·ªçc nhanh c√¢u h·ªèi b·ªô nh·ªõ tr∆∞·ªõc khi g·ªçi LLM (Ti·∫øt ki·ªám chi ph√≠)
        if (isMemoryRelatedQuestion(query)) {
            return QueryIntent.MEMORY_QUERY;
        }

        try {
            // 2. ‚úÖ N√ÇNG C·∫§P PROMPT: Th√™m MEMORY_QUERY v√†o prompt c·ªßa LLM (cho c√°c tr∆∞·ªùng h·ª£p ph·ª©c t·∫°p h∆°n)
            String systemPrompt = "B·∫°n l√† m·ªôt AI ph√¢n lo·∫°i truy v·∫•n. " +
                "Nhi·ªám v·ª• c·ªßa b·∫°n l√† ƒë·ªçc truy v·∫•n v√† quy·∫øt ƒë·ªãnh n√≥ thu·ªôc lo·∫°i n√†o trong ba lo·∫°i sau:\n" +
                "1. RAG_QUERY: N·∫øu ng∆∞·ªùi d√πng ƒëang h·ªèi m·ªôt c√¢u h·ªèi c·ª• th·ªÉ, y√™u c·∫ßu th√¥ng tin, t√≥m t·∫Øt, ph√¢n t√≠ch, ho·∫∑c h·ªèi v·ªÅ c√°c s·ª± ki·ªán trong qu√° kh·ª© (v√≠ d·ª•: 'gi·∫£i th√≠ch X', 't·∫°i sao Y').\n" +
                "2. CHITCHAT: N·∫øu ng∆∞·ªùi d√πng ch·ªâ ƒëang ch√†o h·ªèi, c·∫£m ∆°n, ho·∫∑c n√≥i c√¢u x√£ giao ng·∫Øn (v√≠ d·ª•: 'hi', 'c·∫£m ∆°n b·∫°n', 'tuy·ªát v·ªùi').\n" +
                "3. MEMORY_QUERY: N·∫øu c√¢u h·ªèi ch√≠nh ch·ªâ l√† h·ªèi v·ªÅ n·ªôi dung cu·ªôc tr√≤ chuy·ªán v·ª´a di·ªÖn ra (v√≠ d·ª•: 'b·∫°n ƒë√£ n√≥i g√¨', 'tin nh·∫Øn cu·ªëi c·ªßa t√¥i l√† g√¨').\n\n" +
                "Ch·ªâ tr·∫£ v·ªÅ M·ªòT T·ª™: RAG_QUERY, CHITCHAT, ho·∫∑c MEMORY_QUERY.";
            
            String response = chatLanguageModel.generate(systemPrompt + "\n\nTruy v·∫•n: " + query);

            if (response.contains("MEMORY_QUERY")) {
                return QueryIntent.MEMORY_QUERY;
            } else if (response.contains("RAG_QUERY")) {
                return QueryIntent.RAG_QUERY;
            } else {
                return QueryIntent.CHITCHAT;
            }
        } catch (Exception e) {
            log.warn("Query intent classification failed: {}. Falling back to RAG_QUERY.", e.getMessage());
            return QueryIntent.RAG_QUERY;
        }
    }
    
 private final Cache<String, Boolean> technicalQueryCache = Caffeine.newBuilder()
     .maximumSize(1000)
     .expireAfterWrite(1, TimeUnit.HOURS)
     .build();

 private boolean isTechnicalQuery(String query) {
     if (query == null || query.isBlank()) {
         return false;
     }
     return technicalQueryCache.get(query, this::analyzeTechnicalQuery);
 }

 private boolean analyzeTechnicalQuery(String query) {
     String lowerQuery = query.toLowerCase();
     // (ƒê√¢y l√† logic ph√¢n t√≠ch k·ªπ thu·∫≠t c·ªßa b·∫°n, b·∫°n c√≥ th·ªÉ copy l·∫°i
     // logic ƒë·∫ßy ƒë·ªß m√† b·∫°n ƒë√£ vi·∫øt tr∆∞·ªõc ƒë√¢y)
     String[] technicalKeywords = {"java", "code", "api", "error", "exception", "debug", "sql"};
     for (String keyword : technicalKeywords) {
         if (lowerQuery.contains(keyword)) {
             return true;
         }
     }
     return false;
 }
 
    // üî• C√ÅC PH∆Ø∆†NG TH·ª®C LI√äN QUAN ƒê·∫æN H·ªÜ TH·ªêNG CUSTOM C≈® (ƒê√É B·ªä COMMENT OUT) S·∫º B·ªä X√ìA HO√ÄN TO√ÄN
    
    // private boolean isComplexQuery(String query) { ... }
    // private Map<String, Double> getHybridWeightsBasedOnQueryType(String query) { ... }
    // private boolean analyzeTechnicalQuery(String query) { ... } // (ƒê√£ gi·ªØ l·∫°i 1 phi√™n b·∫£n)
    // private boolean containsTechnicalPatterns(String query) { ... }
    // private String detectTopicForQuery(String query) { ... }
    // private String detectTopicWithAI(String content) { ... }
    // private boolean isUserQuery(String query) { ... }
    // private SearchStrategy classifyQuery(String query) { ... }
    // private boolean containsTechnicalKeywords(String query) { ... }
    // private boolean isComplexNaturalLanguage(String query) { ... }
    // private enum SearchStrategy { ... }
    // private void logRetrievalPerformance(...) { ... }
    // private boolean isExplicitRecallQuestion(String prompt) { ... }
    // private List<ChatMessage> removeDuplicates(...) { ... }
    // private List<ChatMessage> getFallbackMessages(...) { ... }
    // private EmotionContext processEmotion(...) { ... }
    // private ConversationState processConversationState(...) { ... }
    // private EmotionContext createNewEmotionContext(...) { ... }
    // private void updateConversationState(...) { ... }
    // private String detectConversationStage(...) { ... }
    // private String detectCurrentTopic(...) { ... }
    // private boolean isFrustratedMessage(String prompt) { ... }
    // private List<Map<String, String>> buildEnhancedPrompt(...) { ... } // üî• ƒê√É X√ìA
    // private String buildRetrievalContext(...) { ... }
    // private String buildSystemPromptWithContext(...) { ... } // üî• ƒê√É X√ìA
    // public List<Map<String, String>> buildPromptWithHierarchicalMemory(...) { ... } // üî• ƒê√É X√ìA
    // private void updateSatisfactionScore(...) { ... }
    // private boolean isRecallQuestion(String prompt) { ... }
    // private boolean isReferenceIntent(String prompt) { ... }
}